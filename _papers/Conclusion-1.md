---
title: "Conclusion-1"
permalink: /paper/cc1/
excerpt: "Note with python3."
modified: 2016-7-30 13:35:15
---

## 字符串的格式化
%d| 整数 
%f| 浮点数
%s| 字符串
%f | 十六进制整数

如果你不太确定应该用什么， %s 永远起作用，它会把任何数据类型转换为字符串

## 字典的有关方法

```python
d = {'Micael':95}
为了避免key不存在的情况
-  key in dict
- dict.get(key,return = -1)
```

## *args 与 **kw
在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用
其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。

*args 代表可变参数   **kw 代表关键字参数

既可以直接pp(1,2,3,4,5) 输入*args
pp(x=99,y=100) 输入*kw

也可以先定义a=[1,2,3,4,5] b={'x':99,'y':100} 再pp(*a,**b)

默认参数一定要是不可改变的，否则就会不断改变
## enumerate
Python内置的enumerate 函数可以把一个list变成索引-元素对

## Generator
- (x**2 for i in range(100))就是一个生成器
- 或者要把函数变成generator，只需要把print b 改为yield b 就可以了。每次next()，就会输出b

## map()和reduce()
我们先看map。map() 函数接收两个参数，一个是函数，一个是序列， map 将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。

```python
map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])
['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：

```python
>>> def add(x, y):
... return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25
```

## filter
Python内建的filter() 函数用于过滤序列。

和map() 类似， filter() 也接收一个函数和一个序列。和map() 不同的时， filter() 把传入的函数依次作用于每个元素，然后根据返回值是True 还是False 决定保留还是丢弃该元素。

## 排序
通常规定，对于两个元素x 和y ，如果认为x < y ，则返回‐1 ，如果认为x == y ，则返回0 ，如果认为x > y ，则返回1 ，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

Python内置的sorted() 函数就可以对list进行排序：

## Iterable and Iterator
### Iterable 可迭代对象
可以用于for循环。
判断：isinstance(unknown,Iterable) True可迭代，False反之。
### Iterator 迭代器
可以用于for循环，也可以不断调用next()返回下一个值的。

### 转换
把list、dict、str等Iterable变成Iterator可以使用iter()函数

## Decorator
```python
def log(func):
    def wrapper(*args,**kw):
        print("FFSJ")
        return func(*args,**kw)
    return wrapper //替换了vow函数为wrapper函数

@log
def vow():
    print('I love you!')
```
## Something Trivial
isinstance(dict1,dict) = type(dict1) == dict

## 进制转换

十六进制 到 十进制**

使用 int() 函数 ，第一个参数是字符串 '0Xff' ,第二个参数是说明，这个字符串是几进制的数。  转化的结果是一个十进制数。

\>>> int('0xf',16) 
15

**二进制 到 十进制**

\>>> int('10100111110',2)      
1342

**八进制 到 十进制**

\>>> int('17',8)    
15

其实可以看到，不管 几进制数 转换成 十进制数 ，都是用 int()  函数 。之后后面的 第二个参数 写清楚 前面字符串 是 几进制数就可以 。注意一定要合法。 比如2进制数就不能出现2这样的字符。

\----------------------------------------------------------------------------------------------------------------------------

**十进制 转 十六进制**

\>>> hex(1033)
'0x409'

**二进制 转 十六进制**

就是 二进制先转成 十进制， 再转成 十六进制。

\>>> hex(int('101010',2))
'0x2a'

**八进制到 十六进制**

就是 八进制先转成 十进制， 再转成 十六进制。

\>>> hex(int('17',8))
'0xf'

\----------------------------------------------------------------------------------------------------------------------------

**十进制转二进制**

\>>> bin(10)
'0b1010'

**十六进制转 二进制**

十六进制->十进制->二进制

\>>> bin(int('ff',16))
'0b11111111'

**八进制 到 二进制**

八进制先到十进制，再到二进制

\>>> bin(int('17',8))
'0b1111'

\----------------------------------------------------------------------------------------------------------------------------

**二进制 到 八进制**

\>>> oct(0b1010)        
'012'

**十进制到八进制**

\>>> oct(11)
'013'

**十六进制到八进制**

\>>> oct(0xf) 
'017'

可见oct 函数 可将 任意进制的数 转换成 8进制的。

## functools.partial

```python
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
```

所以，简单总结`functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

# module

### how to write a module.py

```python
#!/usr/bin/env python3 //让文件可以直接在unix系统上运行
# -*- coding: utf-8 -*-  //编码utf-8

' a test module '  //第一个字符串默认为注释

__author__ = 'Jake Ming' //your signature
```

### if "\_\_name__"="\_\_main\_\_":test()

当文件于命令行中运行的时候，运行test()

而当通过import引入的时候不会运行。

### 作用域

正常的函数和变量名是公开的（public），可以被直接引用，比如：`abc`，`x123`，`PI`等；

类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，`hello`模块定义的文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名；

类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用，比如`_abc`，`__abc`等；

之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

## 面向对象编程——Object Oriented Programming

Class--instance

数据封装、继承和多态是面向对象的三大特点

### 类的声明

`class Student(object):`类名通常是大写的。object表明从哪个父类继承下来的，通常如果没有合适的继承类，就使用object类，这是所有的类都会继承的类。

### 访问限制

- 以__开头的变量被视为私有(private),python将变量的名字修改为 _{{class-name}}\_name,所以在外部更改name会创建新的变量name，因为name属性已经改名。
- 以_开头的变量可以从外部访问，但请不要这么做。
- \__name__的以双下划线开头结尾的为特殊变量，可以直接访问。

### isinstance()

判断是否为实例。

###dir()

如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：

类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，

仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：

如果试图获取不存在的属性，会抛出AttributeError的错误：

可以传入一个default参数，如果属性不存在，就返回默认值：

```python
>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
```
要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。

`sum = obj.x + obj.y` 而不要写 `sum = getattr(obj, 'x') + getattr(obj, 'y')`

## \_\_slots\_\_ = 

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性：`class Student(object):    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称`

使用`__slots__`要注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：